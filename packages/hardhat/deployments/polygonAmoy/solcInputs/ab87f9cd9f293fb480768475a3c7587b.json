{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/BopHoardingContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n//The MHGN Hoarding contract was written by @moneyhoardermike with help from Polygon Co-Pilot.\n//Its follows MHGN's Project 6 model and allows for Hoarding/Staking of the token address passed in constructor.\n//This Contract is for BOP \"Blocks Of Passion Token\" hoarding.\ncontract BopHoardingContract is Ownable, ReentrancyGuard {\n    struct Hoarder {\n        uint256 hoarded;\n        uint256 timeHoarded;\n        bool isHoarding;\n        uint256 Total_AllTime_Hoarded;\n        uint256 reward;\n        uint256 Total_AllTime_Reward;\n    }\n    \n    mapping (address => Hoarder) public hoarders;\n    uint256 timeHoarded;\n    uint256 public totalHoarded = 0;\n    uint256 public Total_Hoarders = 0;\n    uint256 public Total_Reward_Pool;\n    ERC20 public hoardingToken;\n\n    event Hoarded(address indexed user, uint256 amount);\n    event Pooled(address indexed user, uint256 amount);\n    event UnHoarded(address indexed user);\n\n    constructor() {\n        hoardingToken = ERC20(0x2C3aFc7E571cAF77C52505c46c33Bb493BF48264);  //Amoy\n    }\n    //Function to hoard tokens.\n    function Hoard(uint256 _amount) external nonReentrant {\n        require(!hoarders[msg.sender].isHoarding, \"Hoarder already exist\");\n        require(hoardingToken.balanceOf(msg.sender) >= 0, \"You cannot hoard more tokens than you hold and hoarding is Non-ReEntry\");\n        hoardingToken.transferFrom(msg.sender, address(this), _amount);\n        hoarders[msg.sender].hoarded += _amount;\n        hoarders[msg.sender].timeHoarded = block.timestamp;\n        hoarders[msg.sender].isHoarding = true;\n        hoarders[msg.sender].Total_AllTime_Hoarded += _amount;\n        totalHoarded += _amount;\n        Total_Hoarders += 1;\n        emit Hoarded(msg.sender, _amount);\n    }\n    //Function to allow hoarders to increase their hoard.\n    function IncreaseHoard(uint256 _amount) public  {\n        require(hoardingToken.balanceOf(msg.sender) >= 0, \"You cannot hoard more tokens than you hold\");\n        hoardingToken.transferFrom(msg.sender, address(this), _amount);\n        hoarders[msg.sender].hoarded += _amount;\n        hoarders[msg.sender].isHoarding = true;\n        hoarders[msg.sender].Total_AllTime_Hoarded += _amount;\n        totalHoarded += _amount;\n        emit Hoarded(msg.sender, _amount);\n    }\n    //Function to calculate reward for current hoard.\n    function calculateReward(address _hoarder) public view returns (uint256) {\n        uint256 hoardingTime = block.timestamp - hoarders[_hoarder].timeHoarded;\n        uint256 annualReward = (hoarders[_hoarder].hoarded * 6) / 100;\n        uint256 reward = (annualReward * hoardingTime) / 31536000;  // 365 days in seconds\n        return reward;\n    }\n    //Function to withdraw hoard and claim rewards\n    function ClaimReward() public {\n        require(hoarders[msg.sender].isHoarding == true, \"You cannot unhoard if you are not hoarding\");\n        require(block.timestamp >= hoarders[msg.sender].timeHoarded + 6 days, \"You cannot Claim in the first 6 days of hoarding following the project 6 model\");\n        hoardingToken.transfer(msg.sender, hoarders[msg.sender].hoarded);\n        totalHoarded -= hoarders[msg.sender].hoarded;\n        uint256 reward = calculateReward(msg.sender);\n        require(hoardingToken.balanceOf(address(this)) >= reward, \"The contract does not have enough tokens to give you the reward\");\n        hoardingToken.transfer(msg.sender, reward);\n        hoarders[msg.sender].Total_AllTime_Reward += reward;\n        hoarders[msg.sender].reward += reward;\n        hoarders[msg.sender].hoarded = 0;\n        hoarders[msg.sender].timeHoarded = 0;\n        hoarders[msg.sender].isHoarding = false;\n        Total_Hoarders -= 1;\n        Total_Reward_Pool -= reward;\n    }\n    //Function to withdraw hoard and claim rewards\n    function Unhoard() public {\n        require(hoarders[msg.sender].isHoarding == true, \"You cannot unhoard if you are not hoarding\");\n        require(block.timestamp >= hoarders[msg.sender].timeHoarded + 6 minutes, \"You cannot unhoard in the first 6 minutes of hoardinging following the project 6 model\");\n        hoardingToken.transfer(msg.sender, hoarders[msg.sender].hoarded);\n        totalHoarded -= hoarders[msg.sender].hoarded;\n        uint256 reward = calculateReward(msg.sender);\n        require(hoardingToken.balanceOf(address(this)) >= reward, \"The contract does not have enough tokens to give you the reward\");\n        hoardingToken.transfer(msg.sender, reward);\n        hoarders[msg.sender].Total_AllTime_Reward += reward;\n        hoarders[msg.sender].reward += reward;\n        hoarders[msg.sender].hoarded = 0;\n        hoarders[msg.sender].timeHoarded = 0;\n        hoarders[msg.sender].isHoarding = false;\n        Total_Hoarders -= 1;\n        Total_Reward_Pool -= reward;\n    }\n    //Read only function that checks the hoarders hoarding time in seconds.\n    function GetHoardingingTimeInSeconds(address _hoarder) public view returns (uint256) {\n        return block.timestamp - hoarders[_hoarder].timeHoarded;\n    }\n    //Read only function that checks the users non-hoarding balance.\n    function CheckBopBalance(address _owner) public view returns (uint256) {\n        return hoardingToken.balanceOf(_owner);\n    }\n        //Read only function that checks the users hoarding balance.\n    function Check_Bop_Hoarded_Balance(address _owner) public view returns (uint256) {\n        return hoarders[_owner].hoarded;\n    }\n    //Transfers tokens to the hoarding rewards pool as a donation the tokens can't be withdrawn!\n    function DonationPool(uint256 _amount) public  {\n        require(hoardingToken.balanceOf(msg.sender) >= 0, \"You cannot pool more tokens than you hold\");\n        hoardingToken.transferFrom(msg.sender, address(this), _amount);\n        Total_Reward_Pool += _amount;\n        emit Pooled(msg.sender, _amount);\n    }\n}"
    },
    "contracts/MhgdDaiMint.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ninterface IMhgdToken {\n    function mint(address, uint256) external;\n    function balanceOf(address, uint256) external;\n    function transfer(address, uint256) external;\n}\n\ncontract MhgdDaiMint is ReentrancyGuard {\n    address public immutable owner;\n      struct Minter {\n        uint256 minted;\n        uint256 mintedAtBlock;\n        bool hasMintedBefore;\n        uint256 minter_AllTime_Minted;\n    }\n\n\n    uint256 public constant SWAP_FEE = 1e16; // 0.01 DAI\n    uint256 public Total_Mint_Transactions = 0;\n    uint256 public Total_Mhgd_Swap_Transactions = 0;\n    uint256 public Total_Dai_Swap_Transactions = 0;\n    uint256 public Total_AllTime_Minted;\n    mapping (address => Minter) public minters;\n\n    IERC20 public daiToken;\n    IMhgdToken public mhgdToken;\n    uint256 public daiReserve;\n    uint256 public mhgdReserve;\n    uint256 public feesCollected;\n    \n    \n\n    constructor (address _owner) {\n        // Address of the DAI token on Sepolia\n        daiToken = IERC20(0x520ff243919E21590785Fe48F5D86106D79166Ee);\n        // Address of the MhgdToken contract\n        mhgdToken = IMhgdToken(0x9460b9fed18Bd5aF7b99d88aaE7723cA331a7D14);\n        owner = _owner;\n    }\n\n    \t// Modifier: used to define a set of rules that must be met before or after a function is executed\n\t// Check the withdraw() function\n\tmodifier isOwner() {\n\t\t// msg.sender: predefined variable that represents address of the account that called the current function\n\t\trequire(msg.sender == owner, \"Not the Owner\");\n\t\t_;\n\t}\n\n    /**\n     * @dev Mints an equivalent amount of MhgdToken for the transferred DAI\n     */\n    function mint(uint256 daiAmount) external nonReentrant {\n        require(daiToken.balanceOf(msg.sender) >= 0, \"You need more Dai to Mint MHGD Tokens SORRY!\");\n        require(daiToken.transferFrom(msg.sender, address(this), daiAmount), \"Transfer of DAI failed\");\n        mhgdToken.mint(msg.sender, daiAmount);\n        minters[msg.sender].minted += daiAmount;\n        minters[msg.sender].mintedAtBlock = block.timestamp;\n        minters[msg.sender].hasMintedBefore = true;\n        minters[msg.sender].minter_AllTime_Minted += daiAmount;\n        Total_AllTime_Minted += daiAmount;\n        Total_Mint_Transactions += 1;\n        daiReserve += daiAmount;\n    }\n    \n    /**\n     * @dev Swaps the MhgdToken to DAI less the swap fee.\n     */\n    function swapMhgd(uint256 mhgdAmount) external nonReentrant {\n        require(daiToken.balanceOf(address(this)) >= (mhgdAmount - SWAP_FEE), \"Not enough DAI in reserve\");\n        require(IERC20(address(mhgdToken)).transferFrom(msg.sender, address(this), mhgdAmount), \"Transfer of MHGD failed\");\n        require(daiToken.transfer(msg.sender, mhgdAmount - SWAP_FEE), \"Transfer of DAI failed\");\n        daiReserve -= mhgdAmount;\n        mhgdReserve += mhgdAmount;\n        feesCollected += SWAP_FEE;\n        daiReserve += SWAP_FEE;\n        Total_Mhgd_Swap_Transactions += 1;\n    }\n \n      /**\n     * @dev Swaps the DAI to MHGD plus the swap fee 0.01 DAI.\n     */\n    function swapDai(uint256 daiAmount) external nonReentrant {\n        require(daiToken.balanceOf(msg.sender) >= daiAmount + SWAP_FEE, \"You need more Dai to Swap for MHGD Tokens SORRY!\");\n        require(daiToken.transferFrom(msg.sender, address(this), daiAmount + SWAP_FEE), \"Transfer of DAI failed\");\n        mhgdToken.transfer(msg.sender, daiAmount);\n        daiReserve += daiAmount;\n        daiReserve += SWAP_FEE;\n        feesCollected += SWAP_FEE;\n        mhgdReserve -= daiAmount;\n        Total_Dai_Swap_Transactions += 1;\n    }\n\n}"
    },
    "contracts/MhgdHoardingContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n//The MHGN Hoarding contract was written by @moneyhoardermike with help from Polygon Co-Pilot.\n//Its follows MHGN's Project 6 model and allows for Hoarding/Staking of the token address passed in constructor.\n//This Contract is for MHGD \"Money Hoarders Global Dollar StableCoin\" hoarding.\ncontract MhgdHoardingContract is Ownable, ReentrancyGuard {\n    struct Hoarder {\n        uint256 hoarded;\n        uint256 timeHoarded;\n        bool isHoarding;\n        uint256 Total_AllTime_Hoarded;\n        uint256 reward;\n        uint256 Total_AllTime_Reward;\n    }\n    \n    mapping (address => Hoarder) public hoarders;\n    uint256 timeHoarded;\n    uint256 public totalHoarded = 0;\n    uint256 public Total_Hoarders = 0;\n    uint256 public Total_Reward_Pool;\n    ERC20 public hoardingToken;\n\n    event Hoarded(address indexed user, uint256 amount);\n    event Pooled(address indexed user, uint256 amount);\n    event UnHoarded(address indexed user);\n\n    constructor() {\n        hoardingToken = ERC20(0x9460b9fed18Bd5aF7b99d88aaE7723cA331a7D14); //Amoy\n    }\n    //Function to hoard tokens.\n    function Hoard(uint256 _amount) external nonReentrant {\n        require(!hoarders[msg.sender].isHoarding, \"Hoarder already exist\");\n        require(hoardingToken.balanceOf(msg.sender) >= 0, \"You cannot hoard more tokens than you hold and hoarding is Non-ReEntry\");\n        hoardingToken.transferFrom(msg.sender, address(this), _amount);\n        hoarders[msg.sender].hoarded += _amount;\n        hoarders[msg.sender].timeHoarded = block.timestamp;\n        hoarders[msg.sender].isHoarding = true;\n        hoarders[msg.sender].Total_AllTime_Hoarded += _amount;\n        totalHoarded += _amount;\n\n        Total_Hoarders += 1;\n        emit Hoarded(msg.sender, _amount);\n    }\n    //Function to allow hoarders to increase their hoard.\n    function IncreaseHoard(uint256 _amount) public  {\n        require(hoardingToken.balanceOf(msg.sender) >= 0, \"You cannot hoard more tokens than you hold\");\n        hoardingToken.transferFrom(msg.sender, address(this), _amount);\n        hoarders[msg.sender].hoarded += _amount;\n        hoarders[msg.sender].isHoarding = true;\n        hoarders[msg.sender].Total_AllTime_Hoarded += _amount;\n        totalHoarded += _amount;\n        emit Hoarded(msg.sender, _amount);\n    }\n    //Function to calculate reward for current hoard.\n    function calculateReward(address _hoarder) public view returns (uint256) {\n        uint256 hoardingTime = block.timestamp - hoarders[_hoarder].timeHoarded;\n        uint256 annualReward = (hoarders[_hoarder].hoarded * 6) / 100;\n        uint256 reward = (annualReward * hoardingTime) / 31536000;  // 365 days in seconds\n        return reward;\n    }\n    //Function to withdraw hoard and claim rewards\n    function ClaimReward() public {\n        require(hoarders[msg.sender].isHoarding == true, \"You cannot unhoard if you are not hoarding\");\n        require(block.timestamp >= hoarders[msg.sender].timeHoarded + 6 days, \"You cannot Claim in the first 6 days of hoarding following the project 6 model\");\n        hoardingToken.transfer(msg.sender, hoarders[msg.sender].hoarded);\n        totalHoarded -= hoarders[msg.sender].hoarded;\n        uint256 reward = calculateReward(msg.sender);\n        require(hoardingToken.balanceOf(address(this)) >= reward, \"The contract does not have enough tokens to give you the reward\");\n        hoardingToken.transfer(msg.sender, reward);\n        hoarders[msg.sender].Total_AllTime_Reward += reward;\n        hoarders[msg.sender].reward += reward;\n        hoarders[msg.sender].hoarded = 0;\n        hoarders[msg.sender].timeHoarded = 0;\n        hoarders[msg.sender].isHoarding = false;\n        Total_Hoarders -= 1;\n        Total_Reward_Pool -= reward;\n    }\n    //Function to withdraw hoard and claim rewards\n    function Unhoard() public {\n        require(hoarders[msg.sender].isHoarding == true, \"You cannot unhoard if you are not hoarding\");\n        require(block.timestamp >= hoarders[msg.sender].timeHoarded + 6 minutes, \"You cannot unhoard in the first 6 minutes of hoardinging following the project 6 model\");\n        hoardingToken.transfer(msg.sender, hoarders[msg.sender].hoarded);\n        totalHoarded -= hoarders[msg.sender].hoarded;\n        uint256 reward = calculateReward(msg.sender);\n        require(hoardingToken.balanceOf(address(this)) >= reward, \"The contract does not have enough tokens to give you the reward\");\n        hoardingToken.transfer(msg.sender, reward);\n        hoarders[msg.sender].Total_AllTime_Reward += reward;\n        hoarders[msg.sender].reward += reward;\n        hoarders[msg.sender].hoarded = 0;\n        hoarders[msg.sender].timeHoarded = 0;\n        hoarders[msg.sender].isHoarding = false;\n        Total_Hoarders -= 1;\n        Total_Reward_Pool -= reward;\n    }\n    //Read only function that checks the hoarders hoarding time in seconds.\n    function Get_HoardingingTime_InSeconds(address _hoarder) public view returns (uint256) {\n        return block.timestamp - hoarders[_hoarder].timeHoarded;\n    }\n    //Read only function that checks the users non-hoarding balance.\n    function Check_Mhgd_Balance(address _owner) public view returns (uint256) {\n        return hoardingToken.balanceOf(_owner);\n    }\n      //Read only function that checks the users hoarding balance.\n    function Check_Mhgd_Hoarded_Balance(address _owner) public view returns (uint256) {\n        return hoarders[_owner].hoarded;\n    }\n    //Do not tranfer tokens directly to contract use Donation_Pool function to have a on-chain verified transaction added to the rewards pool.\n    //Transfers tokens to the hoarding rewards pool as a donation the tokens can't be withdrawn!\n    function Donation_Pool(uint256 _amount) public  {\n        require(hoardingToken.balanceOf(msg.sender) >= 0, \"You cannot pool more tokens than you hold\");\n        hoardingToken.transferFrom(msg.sender, address(this), _amount);\n        Total_Reward_Pool += _amount;\n        emit Pooled(msg.sender, _amount);\n    }\n}"
    },
    "contracts/MhgdUsdcMint.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ninterface IMhgdToken {\n    function mint(address, uint256) external;\n    function balanceOf(address, uint256) external;\n    function transfer(address, uint256) external;\n}\n//Allows for the minting of MHGD stable coin and locks USCD into the contract. \n\n//In production we will remove the withdraw function\n//All MHGD will be created by the two mint contracts for usdc and USDC\n//Liquidity pools can then be created on DEXs using minted MHGD with 1:1 ratio for usdc and USDC \ncontract MhgdUsdcMint is ReentrancyGuard {\n    address public immutable owner;\n      struct Minter {\n        uint256 minted;\n        uint256 mintedAtBlock;\n        bool hasMintedBefore;\n        uint256 minter_AllTime_Minted;\n    }\n\n    error NothingToWithdraw(); // Used when trying to withdraw Ether but there's nothing to withdraw.\n\n    uint256 public constant SWAP_FEE = 10; // 0.01 Usdc\n    uint256 public Total_Mint_Transactions = 0;\n    uint256 public Total_Mhgd_Swap_Transactions = 0;\n    uint256 public Total_Usdc_Swap_Transactions = 0;\n    uint256 public Total_AllTime_Minted;\n    mapping (address => Minter) public minters;\n\n    IERC20 public usdcToken;\n    IMhgdToken public mhgdToken;\n    uint256 public usdcReserve;\n    uint256 public mhgdReserve;\n    uint256 public feesCollected;\n    \n    constructor (address _owner) {\n        // Address of the USDC token on Sepolia\n        usdcToken = IERC20(0x41E94Eb019C0762f9Bfcf9Fb1E58725BfB0e7582);\n        // Address of the MhgdToken contract\n        mhgdToken = IMhgdToken(0x9460b9fed18Bd5aF7b99d88aaE7723cA331a7D14);\n        owner = _owner;\n    }\n\n    /**\n     * @dev Mints an equivalent amount of MhgdToken for the transferred USDC \n     */\n    function mint(uint256 usdcAmount) external  {\n        require(usdcToken.balanceOf(msg.sender) >= 0, \"You need more USDC to Mint MHGD Tokens SORRY!\");\n        require(usdcToken.transferFrom(msg.sender, address(this), usdcAmount), \"Transfer of USDC failed\");\n        mhgdToken.mint(msg.sender, usdcAmount * 1000000000000);\n        minters[msg.sender].minted += usdcAmount * 1000000000000;\n        minters[msg.sender].mintedAtBlock = block.timestamp;\n        minters[msg.sender].hasMintedBefore = true;\n        minters[msg.sender].minter_AllTime_Minted += usdcAmount * 1000000000000;\n        Total_AllTime_Minted += usdcAmount * 1000000000000;\n        Total_Mint_Transactions += 1;\n        usdcReserve += usdcAmount;\n    }\n\n    /**\n     * @dev Swaps the MhgdToken to usdc less the swap fee.\n     */\n    function swapMhgd(uint256 mhgdAmount) external nonReentrant {\n        require(usdcToken.balanceOf(address(this)) >= (mhgdAmount / 1000000000000 - SWAP_FEE), \"Not enough usdc in reserve\");\n        require(IERC20(address(mhgdToken)).transferFrom(msg.sender, address(this), mhgdAmount + SWAP_FEE), \"Transfer of MHGD failed\");\n        require(usdcToken.transfer(msg.sender, mhgdAmount / 1000000000000 - SWAP_FEE), \"Transfer of usdc failed\");\n        usdcReserve -= mhgdAmount / 1000000000000;\n        mhgdReserve += mhgdAmount;\n        feesCollected += SWAP_FEE;\n        usdcReserve += SWAP_FEE;\n        Total_Mhgd_Swap_Transactions += 1;\n    }\n \n      /**\n     * @dev Swaps the usdc to MHGD plus the swap fee 0.01 usdc.\n     */\n    function swapusdc(uint256 usdcAmount) external nonReentrant {\n        require(usdcToken.balanceOf(msg.sender) >= usdcAmount + SWAP_FEE, \"You need more usdc to Swap for MHGD Tokens SORRY!\");\n        require(usdcToken.transferFrom(msg.sender, address(this), usdcAmount + SWAP_FEE), \"Transfer of usdc failed\");\n        mhgdToken.transfer(msg.sender, usdcAmount * 1000000000000);\n        usdcReserve += usdcAmount;\n        usdcReserve += SWAP_FEE;\n        feesCollected += SWAP_FEE;\n        mhgdReserve -= usdcAmount * 1000000000000;\n        Total_Usdc_Swap_Transactions += 1;\n    }\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    // Should be removed in production so liquidity is locked in contract it is add here for testing contract.\n     function withdrawToken(\n        address _beneficiary,\n        address _token\n    ) public onlyOwner {\n        uint256 amount = IERC20(_token).balanceOf(address(this));\n        if (amount == 0) revert NothingToWithdraw();\n        IERC20(_token).transfer(_beneficiary, amount);\n    }\n\n}"
    },
    "contracts/WBOPMint.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ninterface IwbopToken {\n    function mint(address, uint256) external;\n    function balanceOf(address, uint256) external;\n    function transfer(address, uint256) external;\n}\n\ncontract WBOPMint is ReentrancyGuard {\n    address public immutable owner;\n      struct Minter {\n        uint256 minted;\n        uint256 mintedAtBlock;\n        bool hasMintedBefore;\n        uint256 minter_AllTime_Minted;\n    }\n\n\n    uint256 public constant SWAP_FEE = 1e16; // 0.01 BOP\n    uint256 public Total_Mint_Transactions = 0;\n    uint256 public Total_Wbop_Swap_Transactions = 0;\n    uint256 public Total_Bop_Swap_Transactions = 0;\n    uint256 public Total_AllTime_Minted;\n    mapping (address => Minter) public minters;\n\n    IERC20 public bopToken;\n    IwbopToken public wbopToken;\n    uint256 public bopReserve;\n    uint256 public wbopReserve;\n    uint256 public feesCollected;\n    \n    \n\n    constructor (address _owner) {\n        // Address of the BOP token on Sepolia\n        bopToken = IERC20(0x2C3aFc7E571cAF77C52505c46c33Bb493BF48264);\n        // Address of the wbopToken contract Sepolia\n        wbopToken = IwbopToken(0x2B040b07Fee31e75c542b828218Fd7578A122812); //Update this address\n        owner = _owner;\n    }\n\n    \t// Modifier: used to define a set of rules that must be met before or after a function is executed\n\t// Check the withdraw() function\n\tmodifier isOwner() {\n\t\t// msg.sender: predefined variable that represents address of the account that called the current function\n\t\trequire(msg.sender == owner, \"Not the Owner\");\n\t\t_;\n\t}\n\n    /**\n     * @dev Mints an equivalent amount of wbopToken for the transferred BOP\n     */\n    function mint(uint256 bopAmount) external nonReentrant {\n        require(bopToken.balanceOf(msg.sender) >= 0, \"You need more BOP to Mint Wbop Tokens SORRY!\");\n        require(bopToken.transferFrom(msg.sender, address(this), bopAmount), \"Transfer of BOP failed\");\n        wbopToken.mint(msg.sender, bopAmount);\n        minters[msg.sender].minted += bopAmount;\n        minters[msg.sender].mintedAtBlock = block.timestamp;\n        minters[msg.sender].hasMintedBefore = true;\n        minters[msg.sender].minter_AllTime_Minted += bopAmount;\n        Total_AllTime_Minted += bopAmount;\n        Total_Mint_Transactions += 1;\n        bopReserve += bopAmount;\n    }\n    \n    /**\n     * @dev Swaps the wbopToken to BOP less the swap fee.\n     */\n    function swapWbop(uint256 wbopAmount) external nonReentrant {\n        require(bopToken.balanceOf(address(this)) >= (wbopAmount - SWAP_FEE), \"Not enough BOP in reserve\");\n        require(IERC20(address(wbopToken)).transferFrom(msg.sender, address(this), wbopAmount), \"Transfer of Wbop failed\");\n        require(bopToken.transfer(msg.sender, wbopAmount - SWAP_FEE), \"Transfer of BOP failed\");\n        bopReserve -= wbopAmount;\n        wbopReserve += wbopAmount;\n        feesCollected += SWAP_FEE;\n        bopReserve += SWAP_FEE;\n        Total_Wbop_Swap_Transactions += 1;\n    }\n \n      /**\n     * @dev Swaps the BOP to WBOP plus the swap fee 0.01 BOP.\n     */\n    function swapBOP(uint256 bopAmount) external nonReentrant {\n        require(bopToken.balanceOf(msg.sender) >= bopAmount + SWAP_FEE, \"You need more BOP to Swap for Wbop Tokens SORRY!\");\n        require(bopToken.transferFrom(msg.sender, address(this), bopAmount + SWAP_FEE), \"Transfer of BOP failed\");\n        wbopToken.transfer(msg.sender, bopAmount);\n        bopReserve += bopAmount;\n        bopReserve += SWAP_FEE;\n        feesCollected += SWAP_FEE;\n        wbopReserve -= bopAmount;\n        Total_Bop_Swap_Transactions += 1;\n    }\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}